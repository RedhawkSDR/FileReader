<?xml version="1.0" encoding="UTF-8"?>
<!-- 
 This file is protected by Copyright. Please refer to the COPYRIGHT file
 distributed with this source distribution.
 
 This file is part of REDHAWK Basic Components FileReader.
 
 REDHAWK Basic Components FileReader is free software: you can redistribute it and/or modify it
 under the terms of the GNU Lesser General Public License as published by the
 Free Software Foundation, either version 3 of the License, or (at your
 option) any later version.
 
 REDHAWK Basic Components FileReader is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program.  If not, see http://www.gnu.org/licenses/.
-->
<!DOCTYPE properties PUBLIC "-//JTRS//DTD SCA V2.2.2 PRF//EN" "properties.dtd">
<properties>
  <struct id="advanced_properties" mode="readwrite" name="advanced_properties">
    <description>Properties to alter advanced behavior.</description>
    <simple id="debug_output" name="debug_output" type="boolean">
      <description>This will enable additional debug output. Includes debug outputs for pushing packets and SRI, as well as for throttling data. </description>
      <value>false</value>
    </simple>
    <simple id="packet_size" name="packet_size" type="string">
      <description>If packet size &lt;= 0, then the size will be automatically determined.

Allowed Units:
[None = Bytes]
KB (1024 Bytes)
MB (1024^2 Bytes)
GB (1024^3 Bytes)

Note that 512B are reserved for the push packet header.</description>
      <value>0</value>
    </simple>
    <simple id="buffer_size" name="buffer_size" type="string">
      <description>The size of the internal buffer used for storing the packets read from the files.

Allowed Units:
[None = Bytes]
KB (1024 Bytes)
MB (1024^2 Bytes)
GB (1024^3 Bytes)</description>
      <value>20MB</value>
    </simple>
    <simple id="looping" name="looping" type="boolean">
      <description>When true, the file will be read and its data pushed repeatedly until explicitly stopped.</description>
      <value>false</value>
    </simple>
    <simple id="looping_suppress_eos_until_stop" name="looping_suppress_eos_until_stop" type="boolean">
      <description>When true, the EOS is only sent when the playback is explicitly stopped.  Otherwise, the EOS will be sent each time the file is finished.  This property only applies when looping is enabled.</description>
      <value>true</value>
    </simple>
    <simple id="transition_time" name="transition_time" type="long">
      <description>Time to sleep between playback of loops or files.</description>
      <value>0</value>
      <units>ms</units>
    </simple>
    <simple id="throttle_rate" name="throttle_rate" type="string">
      <description>%SAMPLE_RATE% is a reserved string. These will be replaced by the Byte equivalent (in Bps) of the sample rate. If throttle_rate is &lt;= 0, throttling will be disabled.

Allowed Units:
[None = Bps]
Bps
KBps (= 1024 Bps)
MBps (= 1024^2 Bps)
GBps (= 1024^3 Bps)

Note that this rate provides an approximate rate out of the data port. Data processing (type conversion/byteswapping) may slow down output. </description>
      <value>%SAMPLE_RATE%</value>
    </simple>
    <simple id="ignore_header_metadata" name="ignore_header_metadata" type="boolean">
      <description>When ignore_header_metadata is enabled, the data player will always use its values for default_sri, default_sri_keywords, and default_timestamp and ignore what is parsed from the file header.

Note that this property only applies when playing back files with headers (i.e. bluefile and wav).</description>
      <value>false</value>
    </simple>
    <simple id="append_default_sri_keywords" name="append_default_sri_keywords" type="boolean">
      <description>When append_default_sri_keywords is enabled, the default_sri_keywords will be added to whatever keywords that may be extracted from the file header.

Note that this property only applies when playing back files with headers (i.e. bluefile and wav).</description>
      <value>false</value>
    </simple>
    <simple id="data_conversion_normalization" name="data_conversion_normalization" type="boolean">
      <description>When converting to/from floating point values, always assume normalization where to the floating point range of [-1,1], when enabled.</description>
      <value>true</value>
    </simple>
    <simple id="data_type_conversion" name="data_type_conversion" type="boolean">
      <description>If true, data types are converted based on the BULKIO connection type to the uber port. 
If false, data is only casted to that type (output might not be correct). </description>
      <value>true</value>
    </simple>
    <simple id="max_sleep_time" name="max_sleep_time" type="double">
      <description>Maximum amount of time to sleep when throttling. This provides a limitation in case of incorrect parameters with unanticipated functionality.

For example, if you are trying to throttle to a bit rate of 1KB/s but are using a packet size of 2MB, your estimated amount of sleep time between pushPackets would be 2000s which might not be desired.</description>
      <value>5.0</value>
      <units>s</units>
    </simple>
    <simple id="center_frequency_keywords" name="center_frequency_keywords" type="short">
      <description>Select which SRI keywords will be included.</description>
      <value>0</value>
      <enumerations>
        <enumeration label="COL_RF AND CHAN_RF" value="0"/>
        <enumeration label="COL_RF ONLY" value="1"/>
        <enumeration label="CHAN_RF ONLY" value="2"/>
        <enumeration label="NO KEYWORDS" value="-1"/>
      </enumerations>
    </simple>
    <simple id="enable_time_filtering" name="enable_time_filtering" type="boolean">
      <description>When enabled, only the portion of the file within [start_time, stop_time] will be played.</description>
      <value>false</value>
    </simple>
    <simple id="start_time" name="start_time" type="double">
      <description>Time in seconds (relative to the beginning of the file) for which to start playing data from the file. If the value is negative, the beginning of the file is used.
enable_time_filtering must be set to 'true' for this property to have an effect.</description>
      <value>0.0</value>
      <units>Seconds</units>
    </simple>
    <simple id="stop_time" name="stop_time" type="double">
      <description>Time in seconds (relative to the beginning of the file) for which to stop playing data from the file. If the value is negative, the entire file will be used.
enable_time_filtering must be set to 'true' for this property to have an effect.</description>
      <value>-1.0</value>
      <units>Seconds</units>
    </simple>
    <simple id="use_metadata_file" type="boolean">
      <description>Flag to indicate if an accompanying metadata xml file is available and should be used for sri and timestamps. This is only valid for raw data files and typically the metadata file would have been generated by FileWriter.</description>
      <value>false</value>
    </simple>
    <configurationkind kindtype="property"/>
  </struct>
  <simple id="source_uri" mode="readwrite" name="source_uri" type="string">
    <description>The path to the file to be read.

URI accepted prefixes:
file://	Local Filesystem
sca:// 	SCA Filesystem (path relative to SDRROOT/dom)</description>
    <value>file://[path_to_local_file_or_dir] OR sca://[path_to_sca_file_or_dir]</value>
    <kind kindtype="property"/>
    <action type="external"/>
  </simple>
  <simple id="file_format" mode="readwrite" name="file_format" type="string">
    <description>The format of the data found in the file to be read. The BLUEFILE  and WAV options rely on the file header for the full description of the data to be read. Each other option fully describes the data to be read, and most options have up to four components:

Mode: SCALAR (Real) or COMPLEX
Atom size: 8 (Char/Octet), 16 (Short), 32 (Long/Float), or 64 (LongLong/Double)
Data type: Unsigned integer, Signed integer, Floating-point
Byte Order: Big or Little Endian

If the byte order of the input file is different than that of the desired output byte order, byte swapping will occur. The desired output byte order is specified using the output_bulkio_byte_order property, which defaults to host byte order.</description>
    <value>SHORT_LITTLE_ENDIAN</value>
    <enumerations>
      <enumeration label="BLUE/PLATINUM FILE" value="BLUEFILE"/>
      <enumeration label="WAV" value="WAV"/>
      <enumeration label="XML" value="XML"/>
      <enumeration label="SCALAR OCTET (8o)" value="OCTET"/>
      <enumeration label="SCALAR CHAR (8t)" value="CHAR"/>
      <enumeration label="SCALAR USHORT Little Endian (16or)" value="USHORT_LITTLE_ENDIAN"/>
      <enumeration label="SCALAR USHORT Big Endian (16o)" value="USHORT_BIG_ENDIAN"/>
      <enumeration label="SCALAR SHORT Little Endian(16tr)" value="SHORT_LITTLE_ENDIAN"/>
      <enumeration label="SCALAR SHORT Big Endian (16t)" value="SHORT_BIG_ENDIAN"/>
      <enumeration label="SCALAR ULONG Little Endian(32or)" value="ULONG_LITTLE_ENDIAN"/>
      <enumeration label="SCALAR ULONG Big Endian (32o)" value="ULONG_BIG_ENDIAN"/>
      <enumeration label="SCALAR LONG Little Endian (32tr)" value="LONG_LITTLE_ENDIAN"/>
      <enumeration label="SCALAR LONG Big Endian (32t)" value="LONG_BIG_ENDIAN"/>
      <enumeration label="SCALAR FLOAT Little Endian(32fr)" value="FLOAT_LITTLE_ENDIAN"/>
      <enumeration label="SCALAR FLOAT Big Endian (32f)" value="FLOAT_BIG_ENDIAN"/>
      <enumeration label="SCALAR DOUBLE Little Endian (64fr)" value="DOUBLE_LITTLE_ENDIAN"/>
      <enumeration label="SCALAR DOUBLE Big Endian (64f)" value="DOUBLE_BIG_ENDIAN"/>
      <enumeration label="COMPLEX OCTET (8o)" value="COMPLEX_OCTET"/>
      <enumeration label="COMPLEX CHAR (8t)" value="COMPLEX_CHAR"/>
      <enumeration label="COMPLEX USHORT Little Endian (16or)" value="COMPLEX_USHORT_LITTLE_ENDIAN"/>
      <enumeration label="COMPLEX USHORT Big Endian (16o)" value="COMPLEX_USHORT_BIG_ENDIAN"/>
      <enumeration label="COMPLEX SHORT Little Endian (16tr)" value="COMPLEX_SHORT_LITTLE_ENDIAN"/>
      <enumeration label="COMPLEX SHORT Big Endian (16t)" value="COMPLEX_SHORT_BIG_ENDIAN"/>
      <enumeration label="COMPLEX ULONG Little Endian (32or)" value="COMPLEX_ULONG_LITTLE_ENDIAN"/>
      <enumeration label="COMPLEX ULONG Big Endian (32o)" value="COMPLEX_ULONG_BIG_ENDIAN"/>
      <enumeration label="COMPLEX LONG Little Endian (32tr)" value="COMPLEX_LONG_LITTLE_ENDIAN"/>
      <enumeration label="COMPLEX LONG Big Endian (32t)" value="COMPLEX_LONG_BIG_ENDIAN"/>
      <enumeration label="COMPLEX FLOAT Little Endian (32fr)" value="COMPLEX_FLOAT_LITTLE_ENDIAN"/>
      <enumeration label="COMPLEX FLOAT Big Endian (32f)" value="COMPLEX_FLOAT_BIG_ENDIAN"/>
      <enumeration label="COMPLEX DOUBLE Little Endian (64fr)" value="COMPLEX_DOUBLE_LITTLE_ENDIAN"/>
      <enumeration label="COMPLEX DOUBLE Big Endian (64f)" value="COMPLEX_DOUBLE_BIG_ENDIAN"/>
    </enumerations>
    <kind kindtype="property"/>
    <action type="external"/>
  </simple>
  <simple id="sample_rate" mode="readwrite" name="sample_rate" type="string">
    <description>The sample rate at which the data was originally sampled.

Allowed Units:
[None = sps]
Ksps (1e3 sps)
Msps (1e6 sps)
Gsps (1e9 sps)</description>
    <value>25Msps</value>
    <kind kindtype="property"/>
    <action type="external"/>
  </simple>
  <simple id="center_frequency" mode="readwrite" name="center_frequency" type="string">
    <description>The center frequency for use in keywords.

Allowed Units:
[None = Hz]
KHz (1e3 Hz)
MHz (1e6 Hz)
GHz (1e9 Hz)</description>
    <value>0.0</value>
    <kind kindtype="property"/>
    <action type="external"/>
  </simple>
  <simple id="playback_state" mode="readwrite" name="playback_state" type="string">
    <description>The current mode of playback.</description>
    <value>STOP</value>
    <enumerations>
      <enumeration label="STOP" value="STOP"/>
      <enumeration label="PLAY" value="PLAY"/>
      <enumeration label="PAUSE" value="PAUSE"/>
    </enumerations>
    <kind kindtype="property"/>
    <action type="external"/>
  </simple>
  <simple id="output_bulkio_byte_order" mode="readwrite" name="output_bulkio_byte_order" type="string">
    <description>Specifies the byte order (enidaness) of the outgoing BulkIO data. By default, the data will be output with byte order consistent with that of the host (Host Byte Order). If it is desired to explicitly set the output byte order, Big or Little Endian can be selected. If the output BulkIO byte order is different from the byte order of the input file, byte swapping will occur. Host Byte Order should almost always be used because byte order is converted between hosts by CORBA automatically when necessary.</description>
    <value>host_order</value>
    <enumerations>
      <enumeration label="Host Byte Order" value="host_order"/>
      <enumeration label="Little Endian" value="little_endian"/>
      <enumeration label="Big Endian" value="big_endian"/>
    </enumerations>
    <kind kindtype="property"/>
    <action type="external"/>
  </simple>
  <simple id="host_byte_order" mode="readonly" name="host_byte_order" type="string">
    <description>The native byte order (endianness) of the host system.</description>
    <enumerations>
      <enumeration label="Little Endian" value="little_endian"/>
      <enumeration label="Big Endian" value="big_endian"/>
    </enumerations>
    <kind kindtype="property"/>
    <action type="external"/>
  </simple>
  <struct id="default_timestamp" mode="readwrite" name="default_timestamp">
    <description>Optional default timstamp. If default_timestamp/tcmode == -1, system timestamp is used. </description>
    <simple id="tcmode" name="tcmode" type="short">
      <description>The timestamp mode.</description>
      <value>-1</value>
      <enumerations>
        <enumeration label="TCM_OFF" value="0"/>
        <enumeration label="TCM_CPU" value="1"/>
        <enumeration label="TCM_ZTC" value="2"/>
        <enumeration label="TCM_SDN" value="3"/>
        <enumeration label="TCM_SMS" value="4"/>
        <enumeration label="TCM_DTL" value="5"/>
        <enumeration label="TCM_IRB" value="6"/>
        <enumeration label="TCM_SDDS" value="7"/>
        <enumeration label="USE SYSTEM TIMESTAMP (IGNORE THIS STRUCTURE)" value="-1"/>
      </enumerations>
    </simple>
    <simple id="tcstatus" name="tcstatus" type="short">
      <description>The timestamp status.</description>
      <value>0</value>
      <enumerations>
        <enumeration label="TCS_INVALID" value="0"/>
        <enumeration label="TCS_VALID" value="1"/>
      </enumerations>
    </simple>
    <simple id="toff" name="toff" type="double">
      <description>The timestamp offset.</description>
      <value>0</value>
    </simple>
    <simple id="twsec" name="twsec" type="double">
      <description>The whole second part of the timestamp.</description>
      <value>0</value>
    </simple>
    <simple id="tfsec" name="tfsec" type="double">
      <description>The fractional second part of the timestamp.</description>
      <value>0</value>
    </simple>
    <configurationkind kindtype="property"/>
  </struct>
  <struct id="default_sri" mode="readwrite" name="default_sri">
    <description>The default SRI to be used. May be ignored when SRI information is parsed from the file header.  Overrides for this are available in advanced properties.</description>
    <simple id="hversion" name="hversion" type="long">
      <description>Version of the StreamSRI header.</description>
      <value>1</value>
    </simple>
    <simple id="xstart" name="xstart" type="double">
      <description>Start of the stream.</description>
      <value>0.0</value>
    </simple>
    <simple id="xdelta" name="xdelta" type="double">
      <description>Delta between two samples. For digitized RF/IF data, this is often equal to 1/sample_rate. 

If this value is =&lt; 0, then xdelta will be automatically calculated based on value of the sample_rate property.</description>
      <value>0.0</value>
    </simple>
    <simple id="xunits" name="xunits" type="short">
      <description>UNITS_NONE
UNITS_TIME (sec)
UNITS_DELAY (sec) 
UNITS_FREQUENCY (Hz)
UNITS_TIMECODE (Time code format)
UNITS_DISTANCE (m)
UNITS_VELOCITY (m/sec)
UNITS_ACCELERATION (m/sec^2)
UNITS_JERK (m/sec^3)
UNITS_DOPPLER (Hz)
UNITS_DOPPLERRATE (Hz/sec)
UNITS_ENERGY (Joules)
UNITS_POWER (Watts)
UNITS_MASS (grams)</description>
      <value>1</value>
      <enumerations>
        <enumeration label="UNITS_NONE" value="0"/>
        <enumeration label="UNITS_TIME" value="1"/>
        <enumeration label="UNITS_DELAY" value="2"/>
        <enumeration label="UNITS_FREQUENCY" value="3"/>
        <enumeration label="UNITS_TIMECODE" value="4"/>
        <enumeration label="UNITS_DISTANCE" value="5"/>
        <enumeration label="UNITS_VELOCITY" value="6"/>
        <enumeration label="UNITS_ACCELERATION" value="7"/>
        <enumeration label="UNITS_JERK" value="8"/>
        <enumeration label="UNITS_DOPPLER" value="9"/>
        <enumeration label="UNITS_DOPPLERRATE" value="10"/>
        <enumeration label="UNITS_ENERGY" value="11"/>
        <enumeration label="UNITS_POWER" value="12"/>
        <enumeration label="UNITS_MASS" value="13"/>
      </enumerations>
    </simple>
    <simple id="subsize" name="subsize" type="long">
      <description>0 if the data is one dimensional. Greater than 0 if two dimensional.</description>
      <value>0</value>
    </simple>
    <simple id="ystart" name="ystart" type="double">
      <description>Start of second dimension stream.</description>
      <value>0.0</value>
    </simple>
    <simple id="ydelta" name="ydelta" type="double">
      <description>Delta between two samples of second dimension.</description>
      <value>0.0</value>
    </simple>
    <simple id="yunits" name="yunits" type="short">
      <description>NITS_NONE
UNITS_TIME (sec)
UNITS_DELAY (sec) 
UNITS_FREQUENCY (Hz)
UNITS_TIMECODE (Time code format)
UNITS_DISTANCE (m)
UNITS_VELOCITY (m/sec)
UNITS_ACCELERATION (m/sec^2)
UNITS_JERK (m/sec^3)
UNITS_DOPPLER (Hz)
UNITS_DOPPLERRATE (Hz/sec)
UNITS_ENERGY (Joules)
UNITS_POWER (Watts)
UNITS_MASS (grams)</description>
      <value>1</value>
      <enumerations>
        <enumeration label="UNITS_NONE" value="0"/>
        <enumeration label="UNITS_TIME" value="1"/>
        <enumeration label="UNITS_DELAY" value="2"/>
        <enumeration label="UNITS_FREQUENCY" value="3"/>
        <enumeration label="UNITS_TIMECODE" value="4"/>
        <enumeration label="UNITS_DISTANCE" value="5"/>
        <enumeration label="UNITS_VELOCITY" value="6"/>
        <enumeration label="UNITS_ACCELERATION" value="7"/>
        <enumeration label="UNITS_JERK" value="8"/>
        <enumeration label="UNITS_DOPPLER" value="9"/>
        <enumeration label="UNITS_DOPPLERRATE" value="10"/>
        <enumeration label="UNITS_ENERGY" value="11"/>
        <enumeration label="UNITS_POWER" value="12"/>
        <enumeration label="UNITS_MASS" value="13"/>
      </enumerations>
    </simple>
    <simple id="mode" name="mode" type="short">
      <description>Real or complex data.

-1 = Automatically determined by value of &quot;data_type&quot; property
0 = Scalar
1 = Complex </description>
      <value>-1</value>
      <enumerations>
        <enumeration label="REAL / SCALAR" value="0"/>
        <enumeration label="COMPLEX" value="1"/>
        <enumeration label="AUTODETERMINE" value="-1"/>
      </enumerations>
    </simple>
    <simple id="blocking" type="boolean">
      <description>When enabled, block on the pushpacket call when the receiving component's queue is full.</description>
      <value>true</value>
    </simple>
    <simple id="streamID" name="streamID" type="string">
      <description>%FILE_BASENAME% is a reserved string. This will be replaced by the basename of the file currently being read.

This stream identifier is for the SRI structure sent by pushSRI(). This file should correlate to the same stream_id sent with the data. </description>
      <value>%FILE_BASENAME%</value>
    </simple>
    <configurationkind kindtype="property"/>
  </struct>
  <structsequence id="default_sri_keywords" mode="readwrite" name="default_sri_keywords">
    <description>Optional SRI keywords. Additonal keyword overrides are available in advanced properties.</description>
    <struct id="sri_keywords_struct" name="sri_keywords_struct">
      <description>The structure representing an SRI keyword.</description>
      <simple id="id" name="id" type="string">
        <description>The ID of the SRI keyword.</description>
      </simple>
      <simple id="value" name="value" type="string">
        <description>The value of the SRI keyword.</description>
      </simple>
      <simple id="value_type" name="value_type" type="string">
        <description>The data type of the value of the SRI keyword.</description>
        <value>STRING</value>
        <enumerations>
          <enumeration label="STRING" value="STRING"/>
          <enumeration label="BOOLEAN" value="BOOLEAN"/>
          <enumeration label="SHORT" value="SHORT"/>
          <enumeration label="CHAR" value="CHAR"/>
          <enumeration label="FLOAT" value="FLOAT"/>
          <enumeration label="DOUBLE" value="DOUBLE"/>
          <enumeration label="LONG" value="LONG"/>
          <enumeration label="OCTET" value="OCTET"/>
          <enumeration label="USHORT" value="USHORT"/>
        </enumerations>
      </simple>
    </struct>
    <configurationkind kindtype="property"/>
  </structsequence>
  <structsequence id="file_status" mode="readonly" name="file_status">
    <description>Read-only status of files available for playback.</description>
    <struct id="file_status_struct" name="file_status_struct">
      <description>The structure representing a file status.</description>
      <simple id="DCE:b6256a27-33fd-41f4-b302-943a41a35cd3" name="filename" type="string">
        <description>Full path filename, inlcuding the URI prefix.</description>
      </simple>
      <simple id="DCE:4baa9718-1f21-4f46-865c-aec82b00df91" name="file_basename" type="string">
        <description>The filename without the path and URI prefix.</description>
      </simple>
      <simple id="DCE:13fd6762-6b17-4a94-a594-9a492e804382" name="file_size" type="longlong">
        <description>The size of the file in bytes.</description>
        <units>B</units>
      </simple>
      <simple id="DCE:6fb595e7-de50-4e17-b5e7-c4b8d87de624" name="filesystem_type" type="short">
        <description>Determines if you are expecting a local file or sca file.</description>
        <enumerations>
          <enumeration label="LOCAL" value="0"/>
          <enumeration label="SCA" value="1"/>
        </enumerations>
      </simple>
      <simple id="DCE:addfe635-bbef-4c9d-83c2-03dd149a3b49" name="format" type="string">
        <description>This value may not be set until file playback has been started as it can be determined from the file header (i.e. - bluefile and wav).</description>
      </simple>
      <simple id="DCE:ebc0a4de-958f-4785-bbe4-03693c34f879" name="error_msg" type="string">
        <description>Will be blank if no error has occurred.</description>
      </simple>
      <simple id="file_status_struct::metadata_filename" name="metadata_filename" type="string">
        <description>Full path filename of metadata file, inlcuding the URI prefix.</description>
      </simple>
    </struct>
    <configurationkind kindtype="property"/>
  </structsequence>
  <struct id="component_status" mode="readonly" name="component_status">
    <description>The status of the component.</description>
    <simple id="estimated_output_rate" name="estimated_output_rate" type="long">
      <description>The refresh rate of this property will be affected when viewing via the IDE.</description>
      <value>0</value>
      <units>Bps </units>
    </simple>
    <simple id="domain_name" name="domain_name" type="string">
      <description>Name of the domain in which this component exists. &quot;(domainless)&quot; is reported if no domain can be found.</description>
      <value>(domainless)</value>
    </simple>
    <configurationkind kindtype="property"/>
  </struct>
</properties>